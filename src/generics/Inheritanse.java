package generics;

/*
 * Обобщения также могут быть частью иерархии наследования.
 * Главным отличием от необобщенной иерархии будет то, что
 * уточнения типов суперклассы так или иначе должны получить от своих
 * подклассов.
 */

public class Inheritanse {
	public static void Show()
	{
		/*
		 * В обобщенных цепочках вы можете приводить типы по следующему правилу:
		 * 
		 * 	- тип одного экземпляра можно привести к типу другого, если они совместимы
		 *  и их аргументы типа одинаковы. 
		 */
		
		Gen2<Integer> one = new Gen2<Integer>(3);	
		System.out.println(one.getOb());
		
		// Так можно, потому что правило выполняется
		Gen<Integer> two = one;
		System.out.println(two.getOb());
		
		// А также можно идти и в обратную сторону
		one = (Gen2<Integer>) two;
		System.out.println(one.getOb());
		
		/*
		 * Но так делать нельзя
		 */
		//Gen<Long> three = one;
		
		/*
		 * Начиная с JDK7 можно использовать сокращенную запись при
		 * конструировании объектов обобщенных классов, не указывая
		 * после new типы обобщений еще раз.
		 * 
		 * При компилировании этого кода компилятор уже знает типы передаваемых
		 * аргументов, чтобы выполнить проверку и сгенерировать код конструктора.
		 * 
		 * Если предполагается, что ваш код должен работать в более стрых версиях Java,
		 * то такой синтаксис использовать нельзя, и вы должны всегда уточнять типы внутри <>.
		 */
		Gen3<Integer,Integer> four = new Gen3<>(1,2);
		System.out.println(four.getOb());
	}
}

/*
 * Рассмотрим простую цепочку
 */
class Gen<T> {
	T ob;
	
	Gen(T o)
	{
		ob = o;
	}
	
	T getOb()
	{
		System.out.println("Сработал метод класса Gen");
		return ob;
	}
} // class Gen

/*
 * Подкласс сообщает своему родителю (суперклассу) тип
 * 
 * Подкласс не обязательно должен быть и сам обобщенным. Он может передать
 * тип родителю и явно:
 * 
 * class Gen2 extends Gen<Integer> {...}
 */
class Gen2<T> extends Gen<T> {
	Gen2(T o)
	{
		super(o);
	}
	
	// Переопределение метода
	T getOb()
	{
		System.out.println("Сработал метод класса Gen2");
		return super.ob;
	}
	
} // class Gen2

/*
 * Обобщенный подкласс может иметь свои обобщенные типы 
 */

class Gen3<T, V> extends Gen<T>  {
	
	V ob;
	
	Gen3(T p1, V p2)
	{
		super(p1);
		ob = p2;
	}
} // class Gen3

/*
 * С другой стороны, у обобщенного подкласса может быть необобщенный суперкласс
 */

class Gen11 {
	
	int a;
	
	Gen11(int p)
	{
		a = p;
	}
	
} // class Gen11

class Gen22<T> extends Gen11 {
	
	T ob;
	Gen22(T p1, int p2)
	{
		super(p2);
		ob = p1;
	}
} // class Gen22



