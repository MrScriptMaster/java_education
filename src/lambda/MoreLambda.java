package lambda;

/*
 * Рассмотрены другие возможности лямбда-выражений
 */

public class MoreLambda {
	public static void main(String[] args)
	{
		Primer pr1 = new Primer(2);
		
		//----------------------------------
		pr1.show();
	}
}

/*
 * Лямбда-выражения могут использовать статические и простые переменные класса.
 */

class Primer {
	
	int val_1;
	static int val_2 = 0;
	
	Primer(int v1)
	{
		val_2++;
		val_1 = v1;
	}
	
	protected void finalize()
	{
		val_2--;
	}
	
	void show()
	{
		/*
		 * Лямбда-функции могут использовать также локальные переменные функции, в которой они вызываются, но с большим ограничением:
		 * эти переменные должны быть действительно завершенными, т.е. принимать значение один
		 * единственный раз во время инициализации.
		 * 
		 * Действительно завершенной переменной может быть и не константа, но в этом
		 * случае нужно постоянно проверять не изменяется ли переменная где-то в программе.
		 * 
		 * Ситуация, когда лямбда-выражение использует локальную переменную, называется "захватом".
		 */
		
		int a = 4;	// Это не константа, но в функции она не должна изменять значения
		
		IfsFunc lambda = (n) ->
		{
			val_1 = n;
			
			System.out.println(val_2);
			System.out.println(a);
			
			return 0;
		};
		//a = 5;	// ЭТО ОШИБКА
		
		lambda.func(2);
		
		/*
		 * С лямбда-выражениями связана также синтаксическая возможность передачи целой
		 * функции по ссылке в другую функцию.
		 * 
		 * Для этого передаваемая функция должна быть совместима по своей сигнатуре.
		 */
		
		/*
		 * Пример передачи статического метода
		 * 
		 * Мы передаем по ссылке статичный метод strReverse из класса StringOps, пользуясь
		 * тем, что его сигнатура схожа с сигнатурой метода функционального интерфейса
		 * StringFunc.
		 * 
		 * Синтаксис таков:
		 * 	
		 * 		ИмяКласса::ИмяМетода
		 */
		System.out.println(
				stringOp(StringOps::strReverse, "Эта строка будет отражена"));
		
		/*
		 * Пример передачи метода экземпляра
		 * 
		 * Передавать по ссылке можно и методы отдельных экземпляров классов.
		 * Синтаксис в целом остается похжим, но вместо имени класса
		 * вы передаете имя ссылки на экземпляр.
		 */
		// Создадим экземпляр
		StringOps demo_1 = new StringOps();
		
		System.out.println(
				stringOp(demo_1::nonstatStrReverse, "Эта строка будет отражена"));
	}
	
	/*
	 * Этот метод используется, чтобы передавать другие методы по ссылке.
	 * В первом аргументе он использует ссылку на функциональный интерфейс
	 * StringFunc, следовательно любой метод может быть передан по ссылке,
	 * чья сигнатура совпадает. 
	 */
	static String stringOp(StringFunc ifs, String str)
	{
		return ifs.func(str);
	}

}	// class Primer

/*
 * Для демонстрации передачи методов по ссылке
 */

class StringOps {
	
	/*
	 * Этот метод мы передадим по ссылке. Этот метод совместим с методом
	 * func из интерфейса StringFunc.
	 */
	static String strReverse(String str)
	{
		String result = "";
		for (int i  = str.length()-1; i >= 0; i--)
		{
			result += str.charAt(i);
		}
		
		return result;
	}
	
	/*
	 * Этот метод не статичный и мы можем передать его по
	 * ссылке пользуясь ссылкой на экземпляр этого класса.
	 */
	String nonstatStrReverse(String str)
	{
		String result = "";
		for (int i  = str.length()-1; i >= 0; i--)
		{
			result += str.charAt(i);
		}
		
		return result;
	}
	
}



