/*
 * Оператор import подобен оператору using namespace в С++. Если путь к пакету длинные
 * вы можете часть пути импортировать в этот исходный файл, чтобы обращаться к 
 * классам пакета.
 * 
 * Оператор import должен идти сразу после оператора package, если он есть в данном исходном
 * файле.
 * 
 * Импортироваться может как отдельный класс, так и весь пакет.
 */

import java.util.Arrays;
import custpack.Box;		// Чтобы импортировать весь пакет, нужно написать import custpack.*
import pl.*;

/*
 * ПРОЕКТ Java
 * Проекты Java оформляются не так как проекты С++. Обычно Java-проект
 * это набор пакетов. Пакетом в Java называется каталог, в котором хранятся классы.
 * Обычно классы размещаются в разных подпапках пакета. Любой проект хранит по крайней
 * мере один пакет, в котором хранится класс с методом main.
 * 
 * Классы из различных пакетов могут быть импортированы. Эта операция аналогична включению
 * заголовочных файлов в C++.
 * 
 *  Сами пакеты это аналог пространств имен в С++, но на уровне файловой системы.
 */

/*
 * В Java-программе должен существовать по крайней мере один класс,
 * у котрого есть статичный метод main. С этого метода происходит
 * запуск программы на Java.
 * 
 * Имя общедоступного класса, в этом примере Main, должно совпадать с именем
 * исходного файла, иначе произойдет ошибка компиляции. 
 */
public class Main {
	
	public static int iAnotherStatic_1;
	public static int iAnotherStatic_2;

	/*
	 * Если статические переменные нужно инициализировать через вычисления, то эти операции
	 * должны быть произведены в специальном блоке static {}
	 * 
	 * Операции в этом блоке будут произведены один единственный раз при первой загрузке
	 * класса
	 * 
	 */
	
	static {
		int a = 3, b = 4;
		
		iAnotherStatic_1 = a * b;
		iAnotherStatic_2 = a + b;
	}
	
	public static void main (String[] args)
	{
		/*
		 * Вызов системного метода
		 */
		System.out.println("Hello, World");
		System.out.println(iAnotherStatic_1);
		System.out.println(iAnotherStatic_2);
		
		Box box = new Box();
		box.print();
		
		// вызываем класс из импортированного пакета
		Protection p = new Protection();
		p = null;
		
		/*
		 * В языке Java всего 8 примитивов или примитивных типов данных
		 * 
		 * Целые числа:
		 * byte  (1 байт) - аналог char в С/С++
		 * short (2 байта)
		 * int   (4 байта)
		 * long  (8 байтов)
		 * 
		 *  Числа с плавающей запятой:
		 *  float  (4 байта)
		 *  double (8 байтов)
		 *  
		 * Символы:
		 * char    (2 байта) - не путать с char C/C++
		 * 
		 * Логический тип:
		 * boolean (1 байт) - аналог bool 
		 */
		
		byte  TByte = 127;
		short TShort = 25;
		int   TInt = -34;
		long  TLong = 1234;
		
		double TDouble = 3.1415;
		
		/*
		 * Чтобы присвоить переменной float значение, необходимо выполнить
		 * явное приведение одним из следующих способов 
		 */
		float TFloat_1 = 3.1415f;
		float TFloat_2 = (float)3.1415;
		
		/*
		 * Для хранения одного символа, используется тип char
		 */
		char symbol = 'a';
		
		/*
		 * Для хранения строки следует использовать встроенный класс String
		 * 
		 */
		String m_String = new String("У попа была собака");
		System.out.println(m_String);
		
		/*
		 * Булевы переменные используются для проверки условий внутри ветвлений
		 * В отличии от С/С++, ветвления в Java требует строгое соблюдение
		 * типа boolean внутри условной конструкции
		 */
		boolean bCond = true;
		if (bCond)
		{
			System.out.println("условие истинно");
		}
		else
		{
			System.out.println("условие ложно");
		}
		
		/*
		 * ВЕТВЛЕНИЯ
		 * Ветвления в Java строятся аналогично С/С++. Единственным 
		 * ограничением является то, что внутри проверки условия
		 * обязательно должно быть логическое значение.
		 * 
		 * Операции, результатом которых являются логические значения:
		 * 
		 * < <= > >= == != && ||
		 */
		
		if (TByte > TShort)
		{
			TByte = (byte)TShort;
		}
		else
		if (TByte == 5)
		{
			TByte -= 1;
		}
		
		/*
		 * Также можно писать ветвления в строчку
		 */
		
		int a = 5;
		a = a >=5 ? 67 : 34;
		
		/*
		 * Язык Java отличает логическое и фактическое равенство для объектов.
		 * Два объекта равны фактически, если они хранятся в одном
		 * и том же месте программы. Например, объект может иметь несколько
		 * ссылок на себя, которые будут сравниваться.
		 * 
		 * Два объекта равны логически, если они являются объектами одного типа
		 * и имеют абсолютно одинаковое содержимое, но при этом занимают разные
		 * участки программы.
		 * 
		 * Для фактического равенства вы используете оператор ==. Для логического
		 * равенства нужно использовать метод equals()	
		 */
		
		String str_1 = new String("wow");
		String str_2 = new String("wow");
		String str_3 = new String("wow1");
		String str_4 = str_1;
		
		System.out.println(str_1 == str_2);			// фактически не равны
		System.out.println(str_1.equals(str_2));	// равны логически
		System.out.println(str_1.equals(str_3));	// не равны логически
		System.out.println(str_1 == str_4);			// равны фактически
		
		/*
		 * МАССИВЫ
		 * Все массивы в Java являются объектами. Массивы объявляются так
		 * 
		 * <тип_хранимых_данных>[] <имя_массива>;
		 * 
		 * Например:
		 * int[] arr;
		 * 
		 * Следует иметь в виду, что массив еще не создан, а только объявлен.
		 * Создать массив нужно через конструктор
		 */
		
		int[] arr;
		arr = new int[10];
		System.out.println(arr.length);
		
		/*
		 * Массив можно создать во время объявления
		 * 
		 */
		int[] arr1 = new int[10];
		/*
		 * Адресуются массивы аналогично языку С/С++
		 */
		arr[0] = 23;
		System.out.println(arr[0]);
		
		/*
		 * Одновременно с объявлением можно также и инициализировать массив
		 */
		
		int[] arr2 = {1,2,3,4,5};
		
		/*
		 * Для вывода массивов на экран следует использовать библиотечные методы,
		 * которые преобразуют их содержимое в строки
		 */
		System.out.println(Arrays.toString(arr));
		System.out.println(Arrays.toString(arr1));
		System.out.println(Arrays.toString(arr2));
		
		/*
		 * Вы можете выводить значения в цикле, если будете обращаться к каждому элементу
		 * по отдельности
		 */
		
		/*
		 * ЦИКЛЫ
		 * В Java всего два типа циклов for и while (с предусловием и постусловием)
		 * Весь синтаксис для циклов полностью аналогичен синтаксису для С/С++
		 */
		
		for (int i=0; i < arr2.length; i++)
		{
			System.out.println(arr2[i]);
		}
		
		/*
		 * Вы можете опускать 1 и 3 параметр для цикла, так как
		 * конструкция выше является конструкцией по умолчанию.
		 * 
		 * Т.е. следующая запись не ошибка
		 * 
		 * for(;i<10;) {...}
		 */
		
		/*
		 * Над элементами массивов удобно применять другой метод записи цикла
		 * for, который позволяет опускать квадратные скобки.
		 * Эта так называемая foreach-запись. В ней вы указываете в какую переменную
		 * нужно записывать значение текущего элемента массива и имя массива, по которому
		 * вы идете. Размер указывать не нужно, потому что конструкция уже знает,
		 * что проход идет в массиве и получает его размер неявно
		 */
		
		for (int el : arr2)
		{
			System.out.println(el);
		}
		// Запись стала проще
		
		/*
		 * Циклы while и do ... while()
		 * ничем не отличаются от синтаксиса С/С++
		 * 
		 * while(условие)
		 * {
		 * 	  действия
		 * }
		 * 
		 * do
		 * {
		 * 	  действия
		 * }
		 * while(условие);
		 * 
		 * Выполнением в цикле можно управлять через ключевые слова continue и break
		 * 
		 */
		
		/*
		 * УДАЛЕНИЕ ОБЪЕКТОВ
		 * 
		 * В Java объекты удаляет сборщик мусора - специальная программа, которая периодически просматривает
		 * объекты в поисках таких, на которые не указывает ни один указатель.
		 * 
		 * Чтобы удалить объект, вы должны фактически удалить ссылку на него
		 * 
		 */
		arr2 = null;
		
		/*
		 * Вы можете вызвать сбощик явно, если не хотите ждать, когда сборка
		 * произойдет автоматически
		 */
		
		System.gc();
		
		// МЕТОДЫ
		method(122221);
		
	} // main
	
	/*
	 * МЕТОДЫ
	 * В Java все функции существуют в контексте какого-либо класса и называются методами.
	 * Большая часть теории относящаяся к методам C++ может быть перенесена на методы Java.
	 * 
	 * Методы бывают:
	 * 
	 * 	- По доступу к ним:
	 * 		-- публичные (public)
	 * 		-- приватные (private)
	 * 		-- защищенные (protected)
	 *  - По контексту памяти:
	 *  	-- статичные (static)
	 *  	-- метод класса
	 *  
	 *  Метод может возвращать значение некоторого типа, а может возвращать void.
	 *  Методам можно передавать несколько аргументов, а можно ничего не передавать.
	 *  
	 *  По умолчанию, методы имеют видимость public
	 * 
	 */
	
	/*
	 * В этом примере мы объявляем два метода. Первый метод при этом перегружен вторым. Методы
	 * объявленые статичными, потому что мы хотим вызывать их из main и не привязывать к объектам.
	 */
	
	static void method()
	{
		return;
	}
		
	static void method(int a)
	{
		System.out.println(a);
	}
	
	/*
	 * КЛАССЫ
	 * Реализация классов в Java немного отличается от реализации классов С++
	 * 
	 * Определение final для всего класса позволяет запретить расширение всего класса
	 */
	public class MyClass {
		/*
		 * Возможность объявления видимости переменной когда угодно
		 * позволяет размещать переменные класса где угодно
		 */
		// члены класса без явно определенной видимости имеют тип private
		int x;
		int y;
		
		// конструктор по умолчанию
		MyClass()
		{
			// внутри одних конструкторов вы можете вызывать другие
			this(0,0);
		}
		
		MyClass(int x, int y)
		{
			this.x = x;
			this.y = y;
		}
		
		void print()
		{
			System.out.println(x);
			System.out.println(y);
		}
		
		/*
		 * В отличие от языка С++, статические переменные внутри класса не обязаны быть проинициализированными явно.
		 * Ключевое слово static говорит о том, что для обращения к переменной данного класса не нужно создавать объект. Кроме того,
		 * эту переменную будут разделять все объекты данного класса.
		 * 
		 * Ключевое слово слово final позволяет превратить статическую переменную в константу.
		 */
		private static final int StaticValue = 55;
	
		/*
		 * Ключевое слово final для метода позволяет предотвратить его переопределение в классах-потомках
		 */
		public final String getBoo()
		{
			/*
			 * Ключевое слово final является аналогом const в следующем контексте
			 */
			final String BooVar = "Boo";
			return BooVar;
		}
		
	}	// MyClass
	
	/*
	 * Чтобы унаследовать класс, используется ключевое слово extends.
	 * За один раз можно унаследовать только один класс, т.е. множественное
	 * наследование в Java невозможно.
	 * 
	 * В целом правила наследования похожи на правила С++:
	 * 
	 * 	-- класс-потомок получает доступ ко всем членам класса-предка (обычно его называют суперклассом), кроме членов private
	 *  -- все методы в суперклассе по умолчанию являются виртуальными (если говорить терминами С++, у них неявно стоит virtual)
	 *  Чтобы отключить для метода виртуальность, используется оператор final.
	 *  
	 *  В Java у конструкторов нет списка инициализации, но вы можете обращаться к членам суперкласса с помощью ключевого слова
	 *  super.
	 */
	
	class NextClass extends MyClass {
		private int z;
		
		NextClass()
		{
			super(0,0);
			this.z = 0;
		}
		
		NextClass(int x, int y, int z)
		{
			super(x,y);
			this.z = z;
		}
		
		// мы переопределили метод суперкласса
		void print()
		{
			// с помощью ключевого слова super мы можем обратиться к методу суперкласса
			super.print();
			System.out.println(z);
		}
	} // NextClass
} // Main
